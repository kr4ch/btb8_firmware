//***************************************************************************************
// Reto Ilg, 2015
// Board/Version: BTB8 V2.0
// Hardware test program v0.1
//***************************************************************************************

FUNCTION CONFIGIO()
DIM rc
	// Unused GPIO: DIGITAL_OUT LOW
	rc = GPIOSetFunc(2,2,0)		: rc = GPIOSetFunc(3,2,0)	: rc = GPIOSetFunc(4,2,0)	// unused ADC inputs
	rc = GPIOSetFunc(5,2,0)		: rc = GPIOSetFunc(6,2,0)								// unused ADC inputs
	rc = GPIOSetFunc(16,2,0)	// unused, TP12
	rc = GPIOSetFunc(17,2,0)	// unused, TP13
	rc = GPIOSetFunc(18,2,0)	// unused, TP14
	rc = GPIOSetFunc(19,2,0)	// unused, TP15
	rc = GPIOSetFunc(20,2,0)	: rc = GPIOSetFunc(26,2,0)	: rc = GPIOSetFunc(27,2,0)	// not connected
	// ADC
	rc = GPIOSetFunc(1,3,0x13)	// AIN1: Battery Voltage ADC input, 10-bit, 1/3 scaling
	rc = GPIOSetFunc(2,3,0x13)	// AIN2: unused ADC input, 10-bit, 1/3 scaling
	// DIGITAL_OUT
	rc = GPIOSetFunc(13,2,1)	// SPI-Flash Chip-Select (Active-Low)
	rc = GPIOSetFunc(0,2,1)		// Status LED (green) ON
	rc = GPIOSetFunc(25,2,0)	// Digital Output for Mux A0
	rc = GPIOSetFunc(29,2,0)	// Digital Output for Mux A1
	rc = GPIOSetFunc(30,2,0)	// Digital Output for Mux A2
	// DIGITAL_IN
	rc = GPIOSetFunc(15,1,0x00)	// Alert 1 Input, no pull resistors
	rc = GPIOSetFunc(14,1,0x00)	// Alert 2 Input, no pull resistors
ENDFUNC 1

SUB SetMux(rc)
	DIM bit[3] as INTEGER
	PRINT "Multiplexer Kanal: "; rc; " \n"
	rc = rc - 1					// Korrektur, da Mux1 = 000
	bit[0] = rc%2				// Berechne A0
	bit[1] = (rc/2)%2			// Berechne A1
	bit[2] = (rc/2/2)%2			// Berechne A2
	rc = GPIOSetFunc(25,2,bit[0])	// Digital Output for Mux A0
	rc = GPIOSetFunc(29,2,bit[1])	// Digital Output for Mux A1
	rc = GPIOSetFunc(30,2,bit[2])	// Digital Output for Mux A2
	PRINT "Multiplexer A2 A1 A0: "; bit[2];" ";bit[1];" ";bit[0]; " \n\n"
	// Hier muss noch eine Verzögerung eingebaut werden, Umschaltung ist zu schnell für Eingangsfilter
	// Nachfolgend gibt es einige Read-Kommandos, damit sich die Spannung am ADC-Eingang anpasst
	// eine bessere Lösung muss noch gesucht werden (mittels Timer)
	FOR rc=1 TO 100				// ca. 6.8ms Loop
	rc = GPIORead(2)			// ADC Input 2 (unused)
	NEXT
ENDSUB

FUNCTION ReadBatVol()
	DIM rc, VD, ADCsc
	rc = GPIORead(1)			// ADC Input 1 (Battery Voltage)
	VD = 1000*(220+470)/470		// Voltage Divider for calculation
	ADCSc = 10240/36			// Scaling ADC Voltage (3.6V) to DSPu (1024)
	rc = rc*VD/ADCSc			// Calculation into mV
ENDFUNC rc

FUNCTION ReadADCTempRAW()
	DIM rc
	BP 0000						// Breakpoint (weiter mit "resume")
	rc = GPIORead(1)			// ADC Input 1 (Battery Voltage)
ENDFUNC rc


//***************************************************************************************
// Main Program
//***************************************************************************************
DIM rc, Mux
DIM Thm_RAW AS INTEGER	// Thermistor Sensor Raw Value
DIM Bat_mV  AS INTEGER	// Battery Voltage in mV
DIM txtVol$ AS STRING	// Battery Voltage Value as String

rc = CONFIGIO()			// Initialize IO

Mux = 1
SetMux(Mux)				// Set Multiplexer to Channel 1

Thm_RAW = ReadADCTempRAW()
PRINT "Battery Voltage RAW (Kanal ";Mux;"): "; Thm_RAW; " DSPu\n\n"

SPRINT #txtVol$,Thm_RAW

Bat_mV  = ReadBatVol()

PRINT "\nBattery Voltage    : ", Bat_mV ; " mV\n"

// I2C Interface
DIM handle
rc = I2cOpen(100000,0,handle)

IF rc!= 0 THEN
	PRINT "\nFailed to open I2C interface with error code "; INTEGER.h' rc
ELSE
	PRINT "\nI2C open success \nHandle is ";handle
ENDIF

BP 0001

I2cClose(handle)  //close the port

BP 0002

// SPI Interface
DIM h
// GPIOWrite(13,1)			// SPI-Flash Chip-Select:	0=active
// rc = SpiOpen(0,125000,0,h)

BP 0003


